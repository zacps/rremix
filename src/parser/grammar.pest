// Magic rule (see pest docs)
WHITESPACE = _{ " " }

// Terminals
//----------------------------------
alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }
// symbols allowed in variable names; todo: this should be expanded to almost every character
symbol = { "-" | lead_symbol }
// Symbols allowed to lead name parts; todo: this should be removed/expanded
lead_symbol = { "^" | "↲" | "!" | "." }
operator = {"+" | "-" | "×" | "÷" | "%" | "=" | "≠" | "<" | "≤" | ">" | "≥"}
hash = { "#" }
colon = { ":" }

// Literals
//----------------------------------
number = @{ ("-"{0,1}) ~ digit+ ~ ("." ~ digit+){0,1} }
boolean = { "true" | "false" }
char_double = {!"\"" ~ ANY }
char_single = {!"\'" ~ ANY }
string_double = { "\"" ~ char_double* ~ "\"" }
string_single = { "'" ~ char_single* ~ "'" }
string = @{ string_double | string_single }
literal = { number | boolean | literal_list | string }

// Keywords
//----------------------------------
redo = { "redo" }

// Comments
//----------------------------------
// Comment indicated by a period at the *end* of the line
eol_comment = { (!("."{0,1} ~ NEWLINE) ~ ANY)* ~ "." ~ NEWLINE }
// Comment indicated by sigil at the start of the line
sigiled_comment = { ( "=" | "- " | "." ) ~ (!NEWLINE ~ ANY)+ ~ NEWLINE }
// Comment indicated by a semicolon; from there to end of line
teol_comment = { ";" ~ (!NEWLINE ~ ANY)+ ~ &NEWLINE }

// Lists
//----------------------------------
key_value = {
    variable ~ ":" ~ expression
}
list_item = { expression | key_value }
list = { (list_item ~ ("," | NEWLINE))* ~ list_item{0,1} }
literal_list = { ("{" ~ list  ~ "}") | ("{" ~ "}") }
list_element_assignment = { single_name_part ~ "[" ~ expression ~ "]" ~ ":" ~ expression }

// Names
//----------------------------------

// Variable
variable = @{ "#"{0,1} ~ (alpha | lead_symbol ) ~ (alpha | digit | symbol )* }
// A single word
single_name_part = @{ (alpha | lead_symbol) ~ (alpha | digit | symbol )* }
// One or more words separated by '/', '/optional' is also allowed
name_part = { single_name_part | (single_name_part ~ "/")+ | "/" ~ single_name_part }
// A parethesised parameter
paren = { "(" ~ single_name_part ~ ")" }
// A parethesised reference parameter
ref_name = ${"#" ~ name_part}
ref_paren = { "(" ~ ref_name ~ ")" } // no whitespace between # and name_part
// A name, parameter, or reference parameter
name_paren = { name_part | paren | ref_paren }

// Statements
//----------------------------------

end_of_statement = _{ EOI | NEWLINE | &"]" }
statement = {
    (
        assignment_statement 
        | return_statement
        | redo_statement
        | setter_call
        | list_element_assignment
        | expression
    ) ~ &end_of_statement
}

redo_statement = { redo }

return_statement = { "return" ~ expression* }

assignment_statement = { variable ~ colon ~ expression }

setter_call = { "fail" }

// A block of statements denoted by an indent.
newindent_block = { 
    (new_indent ~ statement) 
    ~ (
        (NEWLINE ~ continue_indent ~ statement ~ &NEWLINE)
        | NEWLINE ~ WHITESPACE* ~ &NEWLINE
    )*
    ~ DROP
}
// A block of statements denoted by an indent, unlike newindent_block
// does not require that it ends in a newline; allowing:
// function call [
//   statement
//   statement
// ] more names
inline_block = { 
    (new_indent ~ statement) 
    ~ (
        (NEWLINE ~ continue_indent ~ statement)
        | NEWLINE ~ WHITESPACE*
    )*
    ~ DROP
}

// Expressions
//----------------------------------

expression = { binary_expression | unary_expression }

binary_expression = { unary_expression ~ operator ~ expression }
unary_expression = { simple_expression | "(" ~ expression ~ ")" }
simple_expression = {
	list_element
	| create_call
	| function_call 
    | literal
    | variable
}
function_call_end = { NEWLINE | EOI | "}" | ")" | "]" | "," | operator }
function_call = {
    (
        single_name_part 
        // Inline literals are allowed without parentheses
        | literal 
        // Other expressions must be paranthesised
        | "(" ~ expression ~ ")"
        // Bracketed blocks
        | "[" ~ statement ~ "]" 
        | "[" ~ teol_comment{0,1} ~ NEWLINE ~ continue_indent ~ inline_block ~ "]"
        // indented block folowed by continuation
        | NEWLINE ~ continue_indent ~ newindent_block ~ NEWLINE ~ continue_indent ~ "…"
        // indented block
        | NEWLINE ~ continue_indent ~ newindent_block
        // continuation
        // | NEWLINE ~ DROP ~ continue_indent ~ "…" 
        // ignore continuations at the end of the line
        | "…" ~ &NEWLINE
    ){2,}
    ~ &function_call_end
}

create_call = { "fail" }
list_element = { single_name_part ~ "[" ~ expression ~ "]" }

// Functions
//----------------------------------

// A function signature
function_signature = { name_paren+ }
// Indentation
// Put an indent on the stack, future indents must match this indent
new_indent = @{ PUSH(" "+ | "\t") }
continue_indent = @{ PEEK_ALL }
// A function definition
function_statements = { 
    (new_indent ~ statement ~ NEWLINE) 
    ~ (
        continue_indent ~ statement ~ NEWLINE
        | WHITESPACE* ~ NEWLINE
    )* 
    ~ DROP 
}
function_definition = { function_signature ~ colon ~ NEWLINE ~ function_statements }


// Top level
//----------------------------------
program = {
    (NEWLINE | eol_comment | sigiled_comment | function_definition | statement)+ ~ EOI
}
